ğŸ“Œ 1. Installation et importation des bibliothÃ¨ques
python
Copier
Modifier
# ğŸ“¦ Installation des bibliothÃ¨ques nÃ©cessaires
!pip install prophet pmdarima

# ğŸ“š Importation des bibliothÃ¨ques
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.seasonal import seasonal_decompose
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
from pmdarima import auto_arima
from prophet import Prophet
from sklearn.metrics import mean_absolute_error, mean_squared_error
ğŸ“Œ 2. Chargement et exploration des donnÃ©es
python
Copier
Modifier
# ğŸ“‚ Chargement des fichiers (les fichiers doivent Ãªtre prÃ©alablement importÃ©s dans Google Colab)
train = pd.read_csv("train.csv", parse_dates=["date"])
holidays = pd.read_csv("holidays_events.csv", parse_dates=["date"])

# ğŸ“Š AperÃ§u des donnÃ©es
print(train.head())
print(holidays.head())

# VÃ©rification des valeurs manquantes
print(train.isnull().sum())

# AgrÃ©gation des ventes par jour
sales_per_day = train.groupby("date")["sales"].sum()

# ğŸ“ˆ Visualisation de la sÃ©rie temporelle
plt.figure(figsize=(12,6))
plt.plot(sales_per_day, color='blue')
plt.title("Evolution des ventes dans le temps")
plt.xlabel("Date")
plt.ylabel("Ventes")
plt.show()
ğŸ“Œ 3. DÃ©composition de la sÃ©rie temporelle
python
Copier
Modifier
# ğŸ“Š DÃ©composition de la sÃ©rie temporelle
decomposition = seasonal_decompose(sales_per_day, model='additive', period=365)

# ğŸ”¹ Affichage des composantes
plt.figure(figsize=(12,8))
decomposition.plot()
plt.show()
ğŸ“Œ 4. Test de stationnaritÃ© (ADF)
python
Copier
Modifier
# ğŸ“ˆ Test de stationnaritÃ© ADF
adf_test = adfuller(sales_per_day)
print(f"ADF Statistic: {adf_test[0]:.4f}")
print(f"p-value: {adf_test[1]:.4f}")

if adf_test[1] > 0.05:
    print("âš ï¸ La sÃ©rie n'est PAS stationnaire. Une diffÃ©renciation est nÃ©cessaire.")
else:
    print("âœ… La sÃ©rie est stationnaire.")
ğŸ“Œ 5. DiffÃ©renciation pour rendre la sÃ©rie stationnaire
python
Copier
Modifier
# ğŸ“‰ DiffÃ©renciation de la sÃ©rie (d=1)
sales_diff = sales_per_day.diff().dropna()

# ğŸ“Š Visualisation aprÃ¨s diffÃ©renciation
plt.figure(figsize=(12,6))
plt.plot(sales_diff, color='red')
plt.title("SÃ©rie aprÃ¨s diffÃ©renciation (d=1)")
plt.xlabel("Date")
plt.ylabel("Ventes diffÃ©renciÃ©es")
plt.show()
ğŸ“Œ 6. SÃ©lection des paramÃ¨tres optimaux (p,d,q) avec ACF/PACF
python
Copier
Modifier
# ğŸ“Š TracÃ©s ACF et PACF
fig, ax = plt.subplots(1, 2, figsize=(12,4))

plot_acf(sales_diff, ax=ax[0])
ax[0].set_title("Autocorrelation (ACF)")

plot_pacf(sales_diff, ax=ax[1])
ax[1].set_title("Autocorrelation Partielle (PACF)")

plt.show()
ğŸ“Œ 7. SÃ©lection automatique des paramÃ¨tres ARIMA avec Auto-ARIMA
python
Copier
Modifier
# ğŸ“Œ Recherche automatique des paramÃ¨tres optimaux
auto_arima_model = auto_arima(sales_per_day, seasonal=False, trace=True, stepwise=True)

# Affichage des meilleurs paramÃ¨tres
print(f"Meilleurs paramÃ¨tres trouvÃ©s : {auto_arima_model.order}")
ğŸ“Œ 8. ModÃ©lisation ARIMA et prÃ©visions
python
Copier
Modifier
# ğŸ“ˆ ModÃ¨le ARIMA avec les meilleurs paramÃ¨tres trouvÃ©s
p, d, q = auto_arima_model.order
model_arima = ARIMA(sales_per_day, order=(p, d, q))
model_arima_fit = model_arima.fit()

# ğŸ”® GÃ©nÃ©ration des prÃ©visions
forecast_arima = model_arima_fit.forecast(steps=90)

# ğŸ“Š Visualisation des prÃ©visions ARIMA
plt.figure(figsize=(12,6))
plt.plot(sales_per_day, label="Ventes rÃ©elles", color="blue")
plt.plot(pd.date_range(start=sales_per_day.index[-1], periods=90, freq='D'), forecast_arima, label="PrÃ©visions ARIMA", color="red", linestyle="dashed")
plt.legend()
plt.title("PrÃ©visions ARIMA")
plt.show()
ğŸ“Œ 9. ModÃ©lisation avec Prophet
python
Copier
Modifier
# ğŸ“Š PrÃ©paration des donnÃ©es pour Prophet
train_grouped = train.groupby("date")["sales"].sum().reset_index()
train_grouped.columns = ["ds", "y"]

# ğŸ“† PrÃ©paration des jours fÃ©riÃ©s
holidays = holidays[holidays["locale"] == "National"][["date", "description"]]
holidays.columns = ["ds", "holiday"]

# ğŸ“ˆ ModÃ¨le Prophet
model_prophet = Prophet(holidays=holidays, yearly_seasonality=True, weekly_seasonality=True, daily_seasonality=False)
model_prophet.fit(train_grouped)

# ğŸ”® PrÃ©visions Prophet
future = model_prophet.make_future_dataframe(periods=90)
forecast_prophet = model_prophet.predict(future)

# ğŸ“Š Visualisation des prÃ©visions Prophet
plt.figure(figsize=(12,6))
plt.plot(train_grouped["ds"], train_grouped["y"], label="DonnÃ©es rÃ©elles", color="blue")
plt.plot(forecast_prophet["ds"], forecast_prophet["yhat"], label="PrÃ©visions Prophet", color="red", linestyle="dashed")
plt.legend()
plt.title("Comparaison des prÃ©visions Prophet vs DonnÃ©es rÃ©elles")
plt.show()
ğŸ“Œ 10. Ã‰valuation des modÃ¨les
python
Copier
Modifier
# ğŸ“Š SÃ©lection de la pÃ©riode de test
test = train_grouped.iloc[-90:]
preds_arima = forecast_arima.values
preds_prophet = forecast_prophet.iloc[-90:]["yhat"].values

# ğŸ“Œ Calcul des erreurs
mae_arima = mean_absolute_error(test["y"], preds_arima)
rmse_arima = np.sqrt(mean_squared_error(test["y"], preds_arima))
mape_arima = np.mean(np.abs((test["y"] - preds_arima) / test["y"])) * 100

mae_prophet = mean_absolute_error(test["y"], preds_prophet)
rmse_prophet = np.sqrt(mean_squared_error(test["y"], preds_prophet))
mape_prophet = np.mean(np.abs((test["y"] - preds_prophet) / test["y"])) * 100

print(f"ğŸ“Œ ARIMA - MAE: {mae_arima:.2f}, RMSE: {rmse_arima:.2f}, MAPE: {mape_arima:.2f}%")
print(f"ğŸ“Œ Prophet - MAE: {mae_prophet:.2f}, RMSE: {rmse_prophet:.2f}, MAPE: {mape_prophet:.2f}%")
âœ… Ce code couvre lâ€™ensemble du projet : exploration, prÃ©paration, modÃ©lisation et Ã©valuation des prÃ©visions avec ARIMA et Prophet.